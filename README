We used a class based approach for our bridge and ports. Our fft was basically a dictionary with timeouts, and we stored our bpdus by a dictionary of where the bpdu came from to an array with one element for every port, holding onto either a bpdu from that source on that port with a timeout, or nothing. The body of our code is essentially a while loop reading from each port on every iteration.

Our program has two states, calculating and active. During the calculation state, the spanning tree is being calculated, and any data messages that come in are stored to be sent out once the spanning tree is fully constructed. An individual bridge considers the spanning tree calculated when all of its neighboring bridges have the same root port as the bridge. Whenever any information indicates that the spanning tree must change (i.e. bpdu timeout or a bpdu that does not match any of those currently stored), the bridge reenters the calculation state and resets itself to recalculate the spanning tree. To avoid incorrect routing information because of old data messages, there is a waiting period after the calculation state ends during which the fft is not updated.

We found this project extremely challenging, especially earlier on before we decided to separate spanning tree calculation and message sending into different states as we were prone to loops. Once this insight was reached, we again faced difficulty with old messages causing incorrect fft information, but this was solved with our delay period.

We tested our code somewhat using unit tests, but for the most part using the provided scripts. We sent all output to a file so we could easily search through it for our unique print statements. Debugging was tedious.

- Ceridwen Driskill, Ty Coghlan
- Team Gilpin
