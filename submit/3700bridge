#!/usr/bin/python3 -u
import sys
import socket
import select
import json
import time
import random

# represents a bridge which has an id, a root bridge, root port, cost to root, and a
# designated bridge
class Bridge:
    def __init__(self, id, num_ports):
        self.id = id
        self.root = id
        self.rootPort = -1
        self.cost = 0
        self.desBridge = id
        self.bpdus = {} # source: [(message, timestamp)] * number of ports
        self.calculating = False
        self.num_ports = num_ports
        self.start = current_milliseconds()

    # adds a source to the bridge's bpdus, or updates it if it already exists
    def update_bpdus(self, source, message, portno):
        now = current_milliseconds()
        if source in self.bpdus:
            self.bpdus[source][portno] = (message, now)
        else:
            self.bpdus[source] = [(None, -1)] * self.num_ports
            self.bpdus[source][portno] = (message, now)
    
    # resets timedout bpdus and reinitialized the calculation state
    def scrub_bpdus(self, portDict, fft):
        for source, ports in self.bpdus.items():
            for i in range(self.num_ports):
                if current_milliseconds() - ports[i][1] > 750 and ports[i][0] != None:
                    ports[i] = (None, -1)
                    self.reset(portDict, fft)
                    self.calculating = True
                    open_ports(portDict)

    # determines whether all bpdus for this bridge have the same root
    def all_same_root(self):
        return all(all(port[0] == None or port[0]['root'] == self.root for port in ports) \
                   for ports in self.bpdus.values()) 

    # determines whether a given bpdu is already contained in the bpdu table
    def has_bpdu(self, message, port):
        result = False
        if message['source'] in self.bpdus:
            for i in range(bridge.num_ports):
                bpdu = self.bpdus[message['source']][i][0]
                if bpdu != None and bpdu['source'] == message['source'] and \
                    bpdu['root'] == message['root'] and \
                    bpdu['cost'] == message['cost']:
                    result = True
        else:
            result = False
        self.update_bpdus(message['source'], message, port)
        return result

    # resets this bridge for spanning tree recalculation
    def reset(self, ports, fft):
        self.root = self.id
        self.rootPort = -1
        self.cost = 0
        self.desBridge = self.id
        self.start = current_milliseconds()
        fft.clear()
        bpdu(self, ports)
    
# represents a port which has a socket, most recent bpdu, open flag, and timeout
class Port:
    def __init__(self, socket):
        self.port = socket
        self.alive = True
        self.flag = True

    # returns this port's socket's fileno
    def fileno(self):
        return self.port.fileno()

# gets the current milliseconds
def current_milliseconds():
    return int(round(time.time() * 1000))

# pads the name with null bytes at the end
def pad(name):
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

# sends a bpdu to all given ports
def bpdu(bridge, ports):
    for key, value in ports.items():
        broadcast(bridge.id, "ffff", 'bpdu',
                  {'portkey': key, 'designated': bridge.desBridge,
                   'root': bridge.root, 'cost': bridge.cost},
                  value.port)

# sends a json message on the given port
def broadcast(source, destination, type, message, port):
    port.send(json.JSONEncoder().encode({'source': source,
                                         'dest': destination,
                                         'type': type,
                                         'message': message}).encode())

# reads from the given port and decodes the json
def read_message(port):
    return json.JSONDecoder().decode(port.port.recv(1500).decode())

# handles a bpdu
def handle_bpdu(bridge, msgPort, message, ports):
    msgBridge = message['source']
    msgRoot = message['root']
    msgCost = message['cost']
    msgPortStruct = ports[msgPort]
    
    # handles the case in which bridge info changes based on the new bpdu
    if (msgRoot < bridge.root) or \
       (not ((msgRoot > bridge.root) or (msgCost + 1 > bridge.cost)) and \
       ((msgCost + 1 < bridge.cost) or (msgBridge < bridge.desBridge))):
        if bridge.root != msgRoot:
            print('New root: %s/%s' % (bridge.id, msgRoot))
        if bridge.rootPort != msgPort:
            print('Root port: %s/%d' % (bridge.id, msgPort))
            bridge.bpdus[msgBridge][msgPort] = (message, current_milliseconds())
        bridge.root = msgRoot
        bridge.rootPort = msgPort
        bridge.cost = msgCost + 1
        bridge.desBridge = msgBridge
        bpdu(bridge, ports)
    # decides how to kill ports
    if msgBridge == bridge.id:
        msgKey = message['portkey']
        if bridge.bpdus[msgBridge][msgKey][1] != -1 and ports[msgKey].flag \
            and ports[msgKey].alive:
            msgPortStruct.flag = False
            msgPortStruct.alive = False
            for source in bridge.bpdus.keys():
                bridge.bpdus[source][msgPort] = (None, -1)
            print('Killed %s/%d' % (bridge.id, msgPort))

# reopens all ports that have not been killed
def open_ports(ports):
    for p in ports.values():
        if p.alive:
            p.flag = True

# closes all necessary ports for the spanning tree
def close_ports(bridge, ports):
    for key, port in ports.items():
        port.flag = False
        messages = [source[key][0] for source in bridge.bpdus.values() if source[key][0] != None]
        # makes sure port is open if it has no bpdus
        if not messages and port.alive:
            port.flag = True
        elif all(m['cost'] >= bridge.cost for m in messages) and \
            any(m['designated'] == bridge.id for m in messages) and port.alive:
            port.flag = True
        elif all(m['cost'] >= bridge.cost and m['source'] > bridge.id for m in messages) \
             and port.alive:
            port.flag = True
    # makes sure the root port is open
    if bridge.rootPort != -1:
        ports[bridge.rootPort].flag = True
    for key, port in ports.items():
        if key != bridge.rootPort:
            if port.flag:
                print('Designated port: %s/%d' % (bridge.id, key))
            else:
                print('Disabled port: %s/%d' % (bridge.id, key))

# handles a data message
def handle_data(source, destination, type, message, msgPort, fft, ports):
    msgID = message['id']
    print('Received message %d on port %d from %s to %s' % (msgID, msgPort, source, destination))
    try:  # ensures that the destination is in the fft, otherwise broadcasts everywhere
        portInfo = fft[destination]
        if portInfo[0] == msgPort:  # message is not sent if it would go out on the same port
            print('Not forwarding message %d' % (msgID))
        elif ports[portInfo[0]].flag and ports[portInfo[0]].alive:
        # makes sure the destination port is open
            print('Forwarding message %d to port %d' % (msgID, portInfo[0]))
            broadcast(source, destination, type, message, ports[portInfo[0]].port)
        else:
            print('Broadcasting message %d to all ports' % msgID)
            for key, value in ports.items():
                if key != msgPort and value.flag and value.alive:
                    broadcast(source, destination, type, message, value.port)
    except KeyError:
        print('Broadcasting message %d to all ports' % msgID)
        for key in ports.keys():
            if key != msgPort and ports[key].flag and ports[key].alive:
                broadcast(source, destination, type, message, ports[key].port)

# updates the given fft with new source information
def update_fft(fft, source, msgPort):
    fft[source] = [msgPort, current_milliseconds()]

# returns a new fft which only includes the entries from the given fft that have not timed out
def scrub_fft(fft):
    newFFT = {}
    for key, value in fft.items():
        if current_milliseconds() - value[1] < 5000:
            newFFT[key] = value
    return newFFT

# flushes all data messages out of the cache
def flush_data(cachedData, fft, ports):
    while cachedData:
        toHandle = cachedData.pop()
        handle_data(toHandle[0], toHandle[1],
                    toHandle[2], toHandle[3], toHandle[4],
                    fft, ports)
    cachedData.clear()

# main
if __name__ == "__main__":
    LAN = sys.argv[2:]
    # our bridge object, holds onto id, root, root port, etc
    bridge = Bridge(sys.argv[1], len(LAN))
    # dictionary with each key being the port number, each value is a port object
    ports = {}
    # timestamp in milliseconds of the last bpdu received
    lastBPDU = 0
    # dictionary with each key being the destination, each value is list of port number, timestamp
    fft = {}
    # list for stored data messages to be forwarded
    cachedData = []
    # milliseconds to spend calculating spanning tree
    wait = 1250
    # milliseconds to spend not updating fft
    save = 2000

    # creates sockets and connects to them
    for x in range(len(LAN)):
        s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        s.connect(pad(LAN[x]))
        ports[x] = Port(s)
    
    print("Bridge %s starting up" % bridge.id)

    # Main loop
    while True:
        # sends out a new bpdu if 500ms have passed since the last one was sent
        if current_milliseconds() - lastBPDU >= 500:
            bpdu(bridge, ports)
            lastBPDU = current_milliseconds()
        # scrubs out old entries from the fft
        fft = scrub_fft(fft)
        bridge.scrub_bpdus(ports, fft)
        if not bridge.calculating:
            flush_data(cachedData, fft, ports)

        ready, ignore, ignore2 = select.select(ports.values(), [], [], 0.25)

        # Reads from each of the ports
        for key, port in ports.items():
            # only reads from a port if it's ready
            if port in ready and port.alive:
                msg = read_message(port)
                # ensures there were no issues reading the message
                if msg:
                    source = msg['source']
                    destination = msg['dest']
                    type = msg['type']
                    message = msg['message']
                    # handles a bpdu message
                    if type == 'bpdu':
                        message['source'] = source
                        # changes the port's most recent bpdu to the new message
                        if not bridge.has_bpdu(message, key) and not bridge.calculating:
                            bridge.calculating = True
                            bridge.reset(ports, fft)
                            open_ports(ports)
                        if bridge.calculating:
                            handle_bpdu(bridge, key, message, ports)
                            if bridge.all_same_root() and \
                                current_milliseconds() - bridge.start > wait:
                                close_ports(bridge, ports)
                                bridge.calculating = False
                   # handles a data message
                    elif type == 'data' and port.flag:
                        # only acts on the data message if the port it came in on is open
                        # updates the fft with the new source info
                        if current_milliseconds() - bridge.start > save:
                            update_fft(fft, source, key)
                        if all(m[3]['id'] != message['id'] for m in cachedData):
                            cachedData.append((source, destination, type, message, key))
